using NarrativeCharts.Models;

using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Text;

namespace NarrativeCharts.Scripting;

/// <summary>
/// Utilities for <see cref="ScriptConverter"/>.
/// </summary>
public static class ScriptConverterUtils
{
	/// <summary>
	/// The class name for the autogenerated character class.
	/// </summary>
	public const string CHARACTER_CLASS = "Characters";
	/// <summary>
	/// The property name for colors in the characters class.
	/// </summary>
	public const string COLORS = "Colors";
	/// <summary>
	/// The class name for the autogenerated location class.
	/// </summary>
	public const string LOCATION_CLASS = "Locations";
	/// <summary>
	/// The namespace autogenerated output is put under.
	/// </summary>
	public const string NAMESPACE = $"{nameof(NarrativeCharts)}.Autogenerated";
	/// <summary>
	/// The class name for the autogenerated time class.
	/// </summary>
	public const string TIME_CLASS = "Time";
	/// <summary>
	/// The property name for Y-Indexes in the locations class.
	/// </summary>
	public const string YINDEXES = "YIndexes";

	/// <summary>
	/// Converts <paramref name="defs"/> to a C# autogenerated equivalent.
	/// </summary>
	/// <param name="defs"></param>
	/// <returns></returns>
	public static string ConvertToCode(this ScriptDefinitions defs)
	{
		const string USINGS =
$@"using {nameof(NarrativeCharts)}.{nameof(Models)};

using {nameof(System)}.{nameof(System.Collections)}.{nameof(System.Collections.Immutable)};";

		return new StringBuilder()
			.AppendLine(USINGS)
			.AppendLine()
			.Append("namespace ").Append(NAMESPACE).AppendLine(";")
			.AppendLine()
			.Append(defs.ConvertTimeToCode())
			.AppendLine()
			.Append(defs.ConvertLocationsToCode())
			.AppendLine()
			.Append(defs.ConvertCharactersToCode())
			.ToString();
	}

	internal static StringBuilder AppendType<T>(this StringBuilder sb)
		=> sb.AppendType(typeof(T));

	internal static StringBuilder AppendType(this StringBuilder sb, Type type)
	{
		// this isn't recursive because the type arguments will never be generic
		if (type.IsGenericType)
		{
			return sb
				.Append(type.Name.Split('`', 2)[0])
				.Append('<')
				.AppendJoin(", ", type.GenericTypeArguments.Select(x => x.Name))
				.Append('>');
		}
		else
		{
			return sb.Append(type.Name);
		}
	}

	internal static string ToValidProperty(string value)
	{
		var sb = new StringBuilder(value.Length);
		for (var i = 0; i < value.Length; ++i)
		{
			var c = value[i];
			// Copied from https://stackoverflow.com/a/60820647
			switch (char.GetUnicodeCategory(c))
			{
				case UnicodeCategory.UppercaseLetter:
				case UnicodeCategory.LowercaseLetter:
				case UnicodeCategory.TitlecaseLetter:
				case UnicodeCategory.ModifierLetter:
				case UnicodeCategory.OtherLetter:
					// Always allowed in C# identifiers
					sb.Append(c);
					continue;

				case UnicodeCategory.LetterNumber:
				case UnicodeCategory.NonSpacingMark:
				case UnicodeCategory.SpacingCombiningMark:
				case UnicodeCategory.DecimalDigitNumber:
				case UnicodeCategory.ConnectorPunctuation:
				case UnicodeCategory.Format:
					// Only allowed after first char
					if (i != 0)
					{
						sb.Append(c);
					}
					continue;
			}
		}
		return sb.ToString();
	}

	// Copied from https://stackoverflow.com/a/24769702
	[return: NotNullIfNotNull(nameof(sb))]
	internal static StringBuilder? TrimEnd(this StringBuilder? sb)
	{
		if (sb == null || sb.Length == 0)
		{
			return sb;
		}

		var i = sb.Length - 1;

		for (; i >= 0; i--)
		{
			if (!char.IsWhiteSpace(sb[i]))
			{
				break;
			}
		}

		if (i < sb.Length - 1)
		{
			sb.Length = i + 1;
		}

		return sb;
	}

	private static StringBuilder AppendProperty<T>(this StringBuilder sb, string property)
	{
		return sb
			.Append("\tpublic static ")
			.AppendType<T>()
			.Append(' ')
			.Append(property)
			.Append(" { get; }");
	}

	private static StringBuilder ConvertCharactersToCode(this ScriptDefinitions defs)
	{
		var sb = new StringBuilder()
			.AppendLine($"public static class {CHARACTER_CLASS}")
			.AppendLine("{");
		var dict = new StringBuilder();

		foreach (var (character, color) in defs.CharacterColors.OrderBy(x => x.Key.Value))
		{
			var property = ToValidProperty(character.Value);

			sb
				.AppendProperty<Character>(property)
				.Append(" = new(\"")
				.Append(character.Value)
				.AppendLine("\");");

			dict
				.Append("\t\t\t[")
				.Append(property)
				.Append("] = ");
			if (color == Hex.Unknown)
			{
				dict
					.AppendLine($"{nameof(Hex)}.{nameof(Hex.Unknown)},");
			}
			else
			{
				dict
					.Append("new(\"")
					.Append(color.Value)
					.AppendLine("\"),");
			}
		}

		{
			sb
				.AppendProperty<ImmutableDictionary<Character, Hex>>(COLORS)
				.AppendLine()
				.AppendLine()
				.AppendLine($"\tstatic {CHARACTER_CLASS}()")
				.AppendLine("\t{")
				.Append($"\t\t{COLORS} = new ")
				.AppendType<Dictionary<Character, Hex>>()
				.AppendLine()
				.AppendLine("\t\t{")
				.Append(dict)
				.AppendLine("\t\t}.ToImmutableDictionary();")
				.AppendLine("\t}");
		}

		return sb.AppendLine("}");
	}

	private static StringBuilder ConvertLocationsToCode(this ScriptDefinitions defs)
	{
		var sb = new StringBuilder()
			.AppendLine($"public static class {LOCATION_CLASS}")
			.AppendLine("{");
		var dict = new StringBuilder();

		foreach (var (location, index) in defs.LocationYIndexes.OrderBy(x => x.Value))
		{
			var property = ToValidProperty(location.Value);

			sb
				.AppendProperty<Location>(property)
				.Append(" = new(\"")
				.Append(location.Value)
				.AppendLine("\");");

			dict
				.Append("\t\t\t")
				.Append(property)
				.AppendLine(",");
		}

		{
			sb
				.AppendProperty<ImmutableDictionary<Location, int>>(YINDEXES)
				.AppendLine()
				.AppendLine()
				.AppendLine($"\tstatic {LOCATION_CLASS}()")
				.AppendLine("\t{")
				.AppendLine($"\t\t{YINDEXES} = new[]")
				.AppendLine("\t\t{")
				.Append(dict)
				.AppendLine("\t\t}")
				.AppendLine("\t\t.Select((x, i) => (Item: x, Index: i))")
				.AppendLine("\t\t.ToImmutableDictionary(x => x.Item, x => x.Index);")
				.AppendLine("\t}");
		}

		return sb.AppendLine("}");
	}

	private static StringBuilder ConvertTimeToCode(this ScriptDefinitions defs)
	{
		var sb = new StringBuilder()
			.AppendLine($"public enum {TIME_CLASS}")
			.AppendLine("{");

		foreach (var (alias, value) in defs.TimeUnitAliases.OrderBy(x => x.Value))
		{
			var property = ToValidProperty(alias);
			// Only ignore members that are purely number names
			// Other syntax errors should be allowed to be output
			if (property.Length == 0 && int.TryParse(alias, out _))
			{
				continue;
			}

			sb
				.Append('\t')
				.Append(alias)
				.Append(" = ")
				.Append(value)
				.AppendLine(",");
		}

		return sb.AppendLine("}");
	}
}